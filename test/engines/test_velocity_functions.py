"""Test velocity functions in all engines."""
import pathlib

import numpy as np
import pytest
import tomli

from infretis.classes.engines.cp2k import CP2KEngine
from infretis.classes.engines.factory import create_engine
from infretis.classes.engines.gromacs import GromacsEngine
from infretis.classes.engines.lammps import LAMMPSEngine
from infretis.classes.system import System

HERE = pathlib.Path(__file__).resolve().parent

# velocities are from a long MD run and may include zero_momentum and stuff
EXPECTED_STDDEV = {
    "cp2k": 0.0007187852735563246,
    "turtlemd": 1.57265889690332,
    "gromacs": 1.1131628,
    "lammps": 0.01573556087968066,
}


def return_turtlemd_engine():
    """Set up a turtlemd engine for the H2 system."""
    input_path = HERE / "../../examples/turtlemd/H2/"
    toml_file = input_path / "infretis.toml"
    with open(toml_file, "rb") as rfile:
        config = tomli.load(rfile)
    engine = create_engine(config)
    engine.input_path = input_path
    engine.rgen = np.random.default_rng()
    engine.vel_settings = {
        "zero_momentum": False,
        "temperature": 300,
    }
    return engine


def return_lammps_engine():
    """Set up a lammps engine for the H2 system."""
    lammps_input_path = HERE / "../../examples/lammps/H2/lammps_input"
    engine = LAMMPSEngine("lmp_mpi", lammps_input_path.resolve(), 0, 0)
    engine.rgen = np.random.default_rng()
    engine.vel_settings = {
        "zero_momentum": False,
        "temperature": 300,
    }
    return engine


def return_gromacs_engine():
    """Set up a gromacs engine for the H2 system."""
    gromacs_input_path = HERE / "../../examples/gromacs/H2/gromacs_input"
    # set`gmx = echo` here because __init__ calls `gmx` with subprocess
    engine = GromacsEngine("echo", gromacs_input_path.resolve(), 0, 0)
    engine.vel_settings = {
        "zero_momentum": True,
        "temperature": 300,
        "infretis_genvel": True,  # generate velocities internally for gromacs
        "mass": [1.008, 1.008],  # only for gmx with infretis_genvel = True
    }
    engine.rgen = np.random.default_rng()
    return engine


def return_cp2k_engine():
    """Set up a cp2k engine for the H2 system."""
    cp2k_input_path = HERE / "../../examples/cp2k/H2/cp2k_input"
    engine = CP2KEngine("cp2k", cp2k_input_path.resolve(), 1, 1)
    engine.rgen = np.random.default_rng()
    engine.vel_settings = {
        "zero_momentum": False,
        "temperature": 300,
    }
    return engine


@pytest.mark.parametrize(
    "engine",
    [
        return_gromacs_engine(),
        return_lammps_engine(),
        return_cp2k_engine(),
        return_turtlemd_engine(),
    ],
)
def test_modify_velocities(tmp_path, engine):
    """Check that we can modify the velocities with an engine,
    and that they are not equal to zero."""
    # folder we wil run from
    folder = tmp_path / "temp"
    folder.mkdir()
    initial_conf = engine.input_path / f"conf.{engine.ext}"
    engine.exe_dir = folder

    system = System()
    system.set_pos((str(initial_conf.resolve()), 0))
    vel_settings = engine.vel_settings

    engine.modify_velocities(system, vel_settings)
    genvel_conf = folder / f"genvel.{engine.ext}"

    assert genvel_conf.is_file()
    # we generated velocities, so we should have non-zero kinetic energy
    assert system.ekin != 0


@pytest.mark.parametrize(
    "engine",
    [
        return_gromacs_engine(),
        return_lammps_engine(),
        return_cp2k_engine(),
        return_turtlemd_engine(),
    ],
)
@pytest.mark.heavy
def test_modify_velicity_distribition(tmp_path, engine):
    """Check that we generate the correct distribution with
    the correct units by comparing std. deviations from
    the generated velocities with the expected std. deviations"""
    # folder we wil run from
    folder = tmp_path / "temp"
    folder.mkdir()
    initial_conf = engine.input_path / f"conf.{engine.ext}"
    engine.exe_dir = folder

    system = System()
    system.set_pos((str(initial_conf.resolve()), 0))
    vel_settings = engine.vel_settings

    engine.modify_velocities(system, vel_settings)
    genvel_conf = folder / f"genvel.{engine.ext}"

    assert genvel_conf.is_file()
    # we generated velocities, so we should have non-zero kinetic energy
    assert system.ekin != 0
    # check that we have the correct velocity units
    # by comparing std.dev from equilibrium run with
    # the ones generated by modify_velocities
    N_samples = 600  # 10 # gives 6*N_samples velocities
    vel_arr = []
    for i in range(N_samples):
        engine.modify_velocities(system, vel_settings)
        genvel_conf = folder / f"genvel.{engine.ext}"
        _, vel, _, _ = engine._read_configuration(system.config[0])
        for veli in vel.flatten():
            vel_arr.append(veli)
    exp = EXPECTED_STDDEV[engine.name]
    calc = np.std(vel_arr)
    # may be a bit strict with N_samples = 600
    assert abs((exp - calc) / exp) * 100 < 5
