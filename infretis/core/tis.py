from __future__ import annotations

import logging
import os
import time
from typing import TYPE_CHECKING, Any

import numpy as np

from infretis.classes.engines.factory import create_engines
from infretis.classes.orderparameter import create_orderparameters
from infretis.classes.path import DEFAULT_MAXLEN, paste_paths

logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
logger.addHandler(logging.NullHandler())


ENGINES: dict = {}


def def_globals(config):
    global ENGINES
    ENGINES = create_engines(config)
    create_orderparameters(ENGINES, config)


if TYPE_CHECKING:  # pragma: no cover
    from collections.abc import Callable

    from numpy.random import Generator

    from infretis.classes.engines.enginebase import EngineBase
    from infretis.classes.path import Path as InfPath
    from infretis.classes.system import System

    # Define a signature for move methods:
    MoveMethod = Callable[..., tuple[bool, InfPath, str]]


def log_mdlogs(inp: str) -> None:
    logs = [log for log in os.listdir(inp) if "log" in log]
    for log in logs:
        with open(os.path.join(inp, log)) as read:
            for line in read:
                if "Performance" in line:
                    logger.info(
                        log + " " + line.rstrip().split()[1] + " ns/day"
                    )


def run_md(md_items: dict[str, Any]) -> dict[str, Any]:
    """run md function."""
    # record start time
    md_items["wmd_start"] = time.time()

    # initiate engine and order parameter function if None
    if len(ENGINES) == 0:
        def_globals(md_items["config"])
    # set mdrun, rng, clean_up
    for ens_num in md_items["ens_nums"]:
        pens = md_items["picked"][ens_num]
        engine = ENGINES[pens["eng_name"]]
        engine.set_mdrun(pens)
        if "rgen-eng" in pens:
            engine.rgen = pens["rgen-eng"]
        engine.clean_up()

    # perform the hw move:
    picked = md_items["picked"]
    accept, trials, status = select_shoot(picked)

    # Record data
    for trial, ens_num in zip(trials, picked.keys()):
        log_mdlogs(picked[ens_num]["exe_dir"])
        md_items["moves"].append(md_items["mc_moves"][ens_num + 1])
        md_items["trial_len"].append(trial.length)
        md_items["trial_op"].append((trial.ordermin[0], trial.ordermax[0]))
        md_items["generated"].append(trial.generated)
        if status == "ACC":
            minus = True if ens_num < 0 else False
            trial.weights = calc_cv_vector(
                trial,
                md_items["interfaces"],
                md_items["mc_moves"],
                cap=md_items["cap"],
                minus=minus,
            )
            picked[ens_num]["traj"] = trial

    md_items.update({"status": status, "wmd_end": time.time()})
    return md_items


def calc_cv_vector(
    path: InfPath,
    interfaces: list[float],
    moves: list[str],
    cap: float | None = None,
    minus: bool = False,
) -> tuple[float, ...]:
    path_max, _ = path.ordermax

    cv = []
    if minus:
        return (1.0 if interfaces[0] <= path_max else 0.0,)

    for idx, intf_i in enumerate(interfaces[:-1]):
        if moves[idx + 1] == "wf":
            intf_cap = cap if cap is not None else interfaces[-1]
            intfs = [interfaces[0], intf_i, intf_cap]
            cv.append(compute_weight(path, intfs, moves[idx + 1]))
        else:
            cv.append(1.0 if intf_i <= path_max else 0.0)
    cv.append(0.0)
    return tuple(cv)


def compute_weight(path: InfPath, interfaces: list[float], move: str) -> float:
    """Compute the High Acceptance path weight after a MC move.

    This function computes the weights that will be used in the
    computation of the P cross. This trick allows the use of
    the High Acceptance version of Stone Skipping or Wire Fencing,
    allowing the acceptance of B to A paths.
    The drawback is that swapping moves needs
    to account also for this different weights.
    The weight 1 will be returned for a path not generated by SS or WF.

    Parameters
    ----------
    path : object like :py:class:`.PathBase`
        This is the input path which will be checked.
    interfaces : list/tuple of floats
        These are the interface positions of the form
        ``[left, middle, right]``.
    move : string, optional
        The MC move to compute the weights for.

    Returns
    -------
    out[0] : float
        The weight of the path.

    """
    weight = 1.0

    if move == "wf":
        wf_weight, _ = wirefence_weight_and_pick(
            path, interfaces[1], interfaces[2]
        )
        weight = 1.0 * wf_weight

    if path.get_start_point(
        interfaces[0], interfaces[2]
    ) != path.get_end_point(interfaces[0], interfaces[2]):
        if move in ("ss", "wf"):
            weight *= 2

    return weight


def wirefence_weight_and_pick(
    path: InfPath,
    intf_l: float,
    intf_r: float,
    return_seg: bool = False,
    ens_set: dict[str, Any] | None = None,
) -> tuple[int, InfPath]:
    """Calculate the weight of a path generated by the Wire Fence move.

    The WF path weight is determined by the total sum of valid sub-path
    phasepoints, where valid WF subpaths are defined as intf_l-intf_l,
    intf_l-intf_r and intf_r-intf_l sub-paths.

    if return_seg = True, a random valid WF sub-path is also returned.

    Parameters
    ----------
    path : object like :py:class:`.PathBase`
        This is the input path which will be trimmed.
    intf_r : float
        This is the position of the RIGHT interface.
    intf_l : float
        This is the position of the LEFT interface.
    return_seg : boolean, optional
        Determines if a random valid WF sub-path is returned or not.

    Returns
    -------
    n_frames: int
        The weight of the path.
    segment : object like :py:class:`.PathBase`
        False (if return_seg=False) else a random valid WF sub-path.

    """
    key_l, key_r = False, False
    path_arr = []
    isave = 0

    for i in range(len(path.phasepoints[:-1])):
        op1 = path.phasepoints[i].order[0]
        op2 = path.phasepoints[i + 1].order[0]

        if (op1 < intf_l and op2 >= intf_r) or (
            op2 < intf_l and op1 >= intf_r
        ):
            pass
        elif op2 >= intf_l > op1 and not key_l:
            isave, key_l = i, True
        elif op2 < intf_r <= op1 and not key_r:
            isave, key_r = i, True
        elif key_r and op2 >= intf_r > op1:
            key_l, key_r = False, False
        elif True in (key_l, key_r) and (
            op2 < intf_l <= op1 or op2 >= intf_r > op1
        ):
            key_l, key_r = False, False
            path_arr.append((isave, i + 1, i - isave))

    n_frames = sum([i[2] for i in path_arr]) if path_arr else 0
    if return_seg and n_frames and ens_set is not None:
        sum_frames = 0
        subpath_select = ens_set["rgen"].random()
        for ipath in path_arr:
            sum_frames += ipath[2]
            if sum_frames / n_frames >= subpath_select:
                new_segment = path.empty_path()
                for j in range(ipath[0], ipath[1] + 1):
                    new_segment.append(path.phasepoints[j])
                new_segment.maxlen = path.maxlen
                new_segment.status = path.status
                new_segment.time_origin = path.time_origin
                new_segment.generated = "ct"
                return n_frames, new_segment
    return n_frames, path.empty_path()


def select_shoot(
    picked: dict[int, Any], start_cond: tuple[str, ...] = ("L",)
) -> tuple[bool, list[InfPath], str]:
    """Select the shooting move to generate a new path.

    The new path will be generated from the input path, either by
    performing a normal shooting or web-throwing. This is
    determined pseudo-randomly by drawing a random number from a
    uniform distribution using the given random generator.

    Parameters
    ----------
    ensemble : dictionary of objects
        It contains:

        * `path_ensemble`: object like :py:class:`.PathEnsemble`
          This is the path ensemble to perform the TIS step for.
        * `path`: object like :py:class:`.PathBase`
          This is the input path which will be used for generating a
          new path.
        * `system`: object like :py:class:`.System`
          System is used here since we need access to the temperature
          and to the particle list.
        * `order_function`: object like :py:class:`.OrderParameter`
          The class used for obtaining the order parameter(s).
        * `engine`: object like :py:class:`.EngineBase`
          The engine to use for propagating a path.
        * `rgen`: object like :py:class:`.RandomGenerator`
          This is the random generator that will be used.
        * `interfaces`: list of floats
          These are the interface positions on form
          [left, middle, right].

    tis_settings : dict
        This dictionary contains the settings for the TIS method. Here we
        explicitly use:

        * `freq`: float, the frequency of how often we should do time
          reversal moves.
        * `shooting_move`: string, the label of the shooting move to perform.

    start_cond : string
        The starting condition for the path. This is determined by the
        ensemble we are generating for - it is 'R'ight or 'L'eft.

    Returns
    -------
    out[0] : boolean
        True if the new path can be accepted.
    out[1] : object like :py:class:`.PathBase`
        The generated path.
    out[2] : string
        The status of the path.

    """
    sh_moves: dict[str, MoveMethod] = {
        "wf": wire_fencing,
        "sh": shoot,
    }

    if len(picked) == 1:
        pens = next(iter(picked.values()))
        engine = ENGINES[pens["eng_name"]]
        ens_set, path = (pens[i] for i in ["ens", "traj"])
        move = ens_set["mc_move"]
        logger.info(
            f"starting {move} in {ens_set['ens_name']}"
            + f" with path_n {path.path_number}"
        )
        start_cond = ens_set["start_cond"]
        accept, new_path, status = sh_moves[move](
            ens_set, path, engine, start_cond=start_cond
        )
        new_paths = [new_path]
    else:
        accept, new_paths, status = retis_swap_zero(picked)

    logger.info(f"Move was {accept} with status {status}\n")
    return accept, new_paths, status


def shoot(
    ens_set: dict[str, Any],
    path: InfPath,
    engine: EngineBase,
    shooting_point: System | None = None,
    start_cond: tuple[str, ...] = ("L",),
) -> tuple[bool, InfPath, str]:
    interfaces = ens_set["interfaces"]
    trial_path = path.empty_path()  # The trial path we will generate.
    if shooting_point is None:
        shooting_point, idx, dek = prepare_shooting_point(
            path, ens_set["rgen"], engine
        )
        kick = check_kick(
            shooting_point, interfaces, trial_path, ens_set["rgen"], dek
        )
    else:
        kick = True
        idx = getattr(shooting_point, "idx", 0)

    # Store info about this point, just in case we have to return
    # before completing a full new path:
    trial_path.generated = ("sh", shooting_point.order[0], idx, 0)
    trial_path.time_origin = path.time_origin + idx
    # We now check if the kick was OK or not:
    if not kick:
        return False, trial_path, trial_path.status
    # OK: kick was either aimless or it was accepted by Metropolis
    # we should now generate trajectories, but first check how long
    # it should be (if the path comes from a load, it is assumed to not
    # respect the detail balance anyway):
    if path.get_move() == "ld" or ens_set.get("allowmaxlength", False):
        maxlen = ens_set.get("maxlength", DEFAULT_MAXLEN)
    else:
        maxlen = min(
            int((path.length - 2) / ens_set["rgen"].random()) + 2,
            ens_set.get("maxlength", DEFAULT_MAXLEN),
        )
    # Since the forward path must be at least one step, the maximum
    # length for the backward path is maxlen-1.
    # Generate the backward path:
    path_back = path.empty_path(maxlen=maxlen - 1)
    # todo this inputs are a mess
    # Set ensemble state to the selected shooting point:
    # ensemble['system'] = shooting_point.copy()
    shpt_copy = shooting_point.copy()
    if not shoot_backwards(
        path_back, trial_path, shpt_copy, ens_set, engine, start_cond
    ):
        return False, trial_path, trial_path.status

    # Everything seems fine, now propagate forward.
    # Note that the length of the forward path is adjusted to
    # account for the fact that it shares a point with the backward
    # path (i.e. the shooting point). The duplicate point is just
    # counted once when the paths are merged by the method
    # `paste_paths` by setting `overlap=True` (which indicates that
    # the forward and backward paths share a point).
    path_forw = path.empty_path(maxlen=(maxlen - path_back.length + 1))
    logger.debug("Propagating forwards for shooting move...")
    # Set ensemble state to the selected shooting point:
    # change the system state.
    # ensemble['system'] = shooting_point.copy()
    shpt_copy = shooting_point.copy()
    success_forw, _ = engine.propagate(
        path_forw, ens_set, shpt_copy, reverse=False
    )
    path_forw.time_origin = trial_path.time_origin
    # Now, the forward propagation could have failed by exceeding the
    # maximum length for the forward path. However, it could also fail
    # when we paste together so that the length is larger than the
    # allowed maximum. We paste first and ask later:
    trial_path = paste_paths(
        path_back,
        path_forw,
        overlap=True,
        maxlen=ens_set.get("maxlength", DEFAULT_MAXLEN),
    )

    # Also update information about the shooting:
    trial_path.generated = (
        "sh",
        shooting_point.order[0],
        idx,
        path_back.length - 1,
    )
    if not success_forw:
        trial_path.status = "FTL"
        # If we reached this point, the backward path was successful,
        # but the forward was not. For the case where the forward was
        # also successful, the length of the trial path cannot exceed
        # the maximum length given in the TIS settings. Thus we only
        # need to check this here, i.e. when given that the backward
        # was successful and the forward not:
        if trial_path.length == ens_set.get("maxlength", DEFAULT_MAXLEN):
            trial_path.status = "FTX"  # exceeds "memory".
        return False, trial_path, trial_path.status

    trial_path.weight = 1.0

    # Deal with the rejections for path properties.
    # Make sure we did not hit the left interface on {0-}
    # Which is the only ensemble that allows paths starting in R
    if (
        "L" not in set(start_cond)
        and "L" in trial_path.check_interfaces(interfaces)[:2]
    ):
        trial_path.status = "0-L"
        return False, trial_path, trial_path.status

    # Last check - Did we cross the middle interface?
    # Don't do this for paths that can start everywhere
    start_cond = ens_set.get("start_cond", start_cond)
    if set(("R", "L")) == set(start_cond):
        pass
    elif not trial_path.check_interfaces(interfaces)[-1][1]:
        # No, we did not cross the middle interface:
        trial_path.status = "NCR"
        return False, trial_path, trial_path.status

    trial_path.status = "ACC"

    return True, trial_path, trial_path.status


def wire_fencing(
    ens_set: dict[str, Any],
    trial_path: InfPath,
    engine: EngineBase,
    start_cond: tuple[str, ...] = ("L",),
) -> tuple[bool, InfPath, str]:
    """Perform a wire_fencing move.

    This function will perform the non famous wire fencing move
    from an initial path.

    Parameters
    ----------
    ensemble: dict
        It contains:

        * `path_ensemble`: object like :py:class:`.PathEnsemble`
          This is the path ensemble to perform the TIS step for.
        * `system`: object like :py:class:`.System`
          System is used here since we need access to the temperature
          and to the particle list.
        * `order_function`: object like :py:class:`.OrderParameter`
          The class used for obtaining the order parameter(s).
        * `engine`: object like :py:class:`.EngineBase`
          The engine to use for propagating a path.
        * `rgen`: object like :py:class:`.RandomGenerator`
          This is the random generator that will be used.
        * `interfaces`: list of floats
          These are the interface positions on form
          [left, middle, right].

    tis_settings : dict
        This contains the settings for TIS. Keys used here:

        * `aimless`: boolean, is the shooting aimless or not?
        * `allowmaxlength`: boolean, should paths be allowed to reach
          maximum length?
        * `maxlength`: integer, maximum allowed length of paths.

    start_cond : string
        The starting condition for the current ensemble, 'L'eft or
        'R'ight.

    Returns
    -------
    out[0] : boolean
        True if the path can be accepted.
    out[1] : object like :py:class:`.PathBase`
        Returns the generated path.
    out[2] : string
        Status of the path, this is one of the strings defined in
        :py:const:`.path._STATUS`.

    """
    old_path = trial_path.copy()
    intf_cap = ens_set["tis_set"].get(
        "interface_cap",
        ens_set["interfaces"][2],
    )
    wf_int = list([ens_set["interfaces"][1]] * 2) + [intf_cap]
    n_frames, new_segment = wirefence_weight_and_pick(
        trial_path, wf_int[0], wf_int[2], return_seg=True, ens_set=ens_set
    )

    # Check if no frames to shoot from
    if n_frames == 0:
        logger.warning("Wire fencing move not usable. N frames of Path = 0")
        logger.warning(f"between interfaces {wf_int[0]} and {wf_int[-1]}.")
        return False, trial_path, "NSG"

    sub_ens = {
        "interfaces": wf_int,
        "rgen": ens_set["rgen"],
        "allowmaxlength": True,
        "maxlength": DEFAULT_MAXLEN,
        "ens_name": ens_set["ens_name"],
        "start_cond": ens_set["start_cond"],
    }

    succ_seg = 0
    for i in range(ens_set["tis_set"].get("n_jumps", 2)):
        logger.debug("Trying a new web with Wire Fencing, jump %i", i)
        success, trial_seg, status = shoot(
            sub_ens, new_segment, engine, start_cond=("L", "R")
        )
        start, end, _, _ = trial_seg.check_interfaces(wf_int)
        logger.info(
            f"Jump {i}, len {trial_seg.length}, status"
            + f"{status}, intf: {start} {end}"
        )
        if not success:
            # This handles R to R (start_cond = L) paths. Counter + 1, no ups.
            logger.debug("Wire Fencing Fail.")
        else:
            logger.debug("Acceptable Wire Fence link.")
            succ_seg += 1
            new_segment = trial_seg.copy()
    if succ_seg == 0:
        # No usable segments were generated.
        trial_path.status = "NSG"
        success = False
    else:
        success, trial_path, _ = extender(
            new_segment, engine, ens_set, start_cond
        )
    if success:
        success, trial_path = subt_acceptance(
            trial_path, ens_set, engine, old_path, start_cond
        )

    trial_path.generated = ("wf", 9000, succ_seg, trial_path.length)

    logger.debug("WF move %s", trial_path.status)
    if not success:
        return False, trial_path, trial_path.status

    # This might get triggered when accepting 0-L paths.
    left, _, right = ens_set["interfaces"]
    # TODO: check this
    # print(start_cond, tuple(trial_path.get_start_point(left, right)))
    assert set(start_cond) == set(
        trial_path.get_start_point(left, right)
    ), "WF: Path has an implausible start."

    trial_path.status = "ACC"
    return True, trial_path, trial_path.status


def subt_acceptance(
    trial_path: InfPath,
    ens_set: dict[str, Any],
    engine: EngineBase,
    path_old: InfPath,
    start_cond: tuple[str, ...] = ("L",),
) -> tuple[bool, InfPath]:
    """Weights, possibly reverses and accept/rejects generated SS/WT/WFpaths.

    Parameters
    ----------
    trial_path : object like :py:class:`.PathBase`
        This is the new path that will obtain weights, and might be reversed
        and accepted.
    ensemble : dict
        It contains:

        * `path_ensemble`: object like :py:class:`.PathEnsemble`
          This is the path ensemble to perform the TIS step for.
        * `order_function`: object like :py:class:`.OrderParameter`
          The class used for obtaining the order parameter(s).
        * `rgen`: object like :py:class:`.RandomGenerator`
          This is the random generator that will be used.
        * `interfaces` : list/tuple of floats
          These are the interface positions of the form
          ``[left, middle, right]``.

    tis_settings : dict
        This contains the settings for TIS. KEys used here;

        * `shooting_move` : string, the label of the shooting move to perform.

    start_cond : string, optional
        The starting condition for the current ensemble, 'L'eft or 'R'ight.

    Returns
    -------
    out[0] : boolean
        True if the path can be accepted.
    out[1] : object like :py:class:`.PathBase`
        Returns the weighed and possibly reversed path.

    """
    intf = list(ens_set["interfaces"])
    move = ens_set["mc_move"]

    if move == "wf":
        intf[2] = ens_set["tis_set"].get("interface_cap", intf[2])
    trial_path.weight = compute_weight(trial_path, intf, move)

    if set(start_cond) != set(trial_path.get_start_point(intf[0], intf[2])):
        trial_path = trial_path.reverse(engine.order_function)

    if set(start_cond) != set(trial_path.get_start_point(intf[0], intf[2])):
        trial_path.status = "BWI"
        return False, trial_path
    trial_path.status = "ACC"
    return True, trial_path


def extender(
    source_seg: InfPath,
    engine: EngineBase,
    ens_set: dict[str, Any],
    start_cond: tuple[str, ...] = ("R", "L"),
) -> tuple[bool, InfPath, str]:
    interfaces = ens_set["interfaces"]
    # ensemble['system'] = source_seg.phasepoints[0].copy()
    sh_pt = source_seg.phasepoints[0].copy()

    # Extender
    if interfaces[0] <= sh_pt.order[0] < interfaces[-1]:
        back_segment = source_seg.empty_path(
            maxlen=ens_set["tis_set"]["maxlength"]
        )
        logger.debug("Trying to extend backwards")
        source_seg_copy = source_seg.copy()

        shoot_backwards(
            back_segment, source_seg_copy, sh_pt, ens_set, engine, start_cond
        )
        trial_path = paste_paths(
            back_segment,
            source_seg,
            overlap=True,
            maxlen=ens_set["tis_set"]["maxlength"],
        )
    else:
        trial_path = source_seg.copy()

    sh_pt = trial_path.phasepoints[-1].copy()
    if interfaces[0] <= sh_pt.order[0] < interfaces[-1]:
        forth_segment = source_seg.empty_path(
            maxlen=ens_set["tis_set"]["maxlength"]
        )
        engine.propagate(forth_segment, ens_set, sh_pt)

        trial_path.phasepoints = (
            trial_path.phasepoints[:-1] + forth_segment.phasepoints
        )

    if trial_path.length >= ens_set["tis_set"]["maxlength"]:
        trial_path.status = "FTX"  # exceeds "memory".
        return False, trial_path, trial_path.status
    trial_path.status = "ACC"
    return True, trial_path, trial_path.status


def shoot_backwards(
    path_back: InfPath,
    trial_path: InfPath,
    system: System,
    ens_set: dict[str, Any],
    engine: EngineBase,
    start_cond: tuple[str, ...],
) -> bool:
    """Shoot in the backward time direction.

    Parameters
    ----------
    path_back : object like :py:class:`.PathBase`
        The path we will fill with phase points from the propagation.
    trial_path : object like :py:class:`.PathBase`
        The current trial path generated by the shooting.
    ensemble : dictionary of objects
        It contains:

        * `order_function`: object like :py:class:`.OrderParameter`
          The class used for obtaining the order parameter(s).
        * `engine`: object like :py:class:`.EngineBase`
          The engine to use for propagating a path.
        * `interfaces`: list/tuple of floats
          These are the interface positions of the form
          ``[left, middle, right]``.
        * `system`: object like :py:class:`.System`
           The system that originates the path.

    tis_settings : dict
        This contains the settings for TIS.
    start_cond : string
        The starting condition for the current ensemble, 'L'eft or
        'R'ight.

    Returns
    -------
    out : boolean
        True if the backward path was generated successfully, False
        otherwise.

    """
    logger.debug("Propagating backwards for the shooting move.")
    path_back.time_origin = trial_path.time_origin
    success_back, _ = engine.propagate(
        path_back, ens_set, system, reverse=True
    )
    if not success_back:
        # Something went wrong, most probably the path length was exceeded.
        trial_path.status = "BTL"  # BTL = backward trajectory too long.
        # Add the failed path to trial path for analysis:
        trial_path += path_back
        if path_back.length >= ens_set.get("maxlength", DEFAULT_MAXLEN) - 1:
            # BTX is backward trajectory longer than maximum memory.
            trial_path.status = "BTX"
        return False
    # Backward seems OK so far, check if the ending point is correct:
    left, _, right = ens_set["interfaces"]
    if path_back.get_end_point(left, right) not in set(start_cond):
        # Nope, backward trajectory end at wrong interface.
        trial_path += path_back  # Store path for analysis.
        trial_path.status = "BWI"
        return False
    return True


def prepare_shooting_point(
    path: InfPath, rgen: Generator, engine: EngineBase
) -> tuple[System, int, float]:
    """Select and modify velocities for a shooting move.

    This method will randomly select a shooting point from a given
    path and modify its velocities.

    Parameters
    ----------
    path : object like :py:class:`.PathBase`
        This is the input path which will be used for generating a
        new path.
    ensemble : dictionary of objects
        It contains:

        * `order_function`: object like :py:class:`.OrderParameter`
          The class used for obtaining the order parameter(s).
        * `engine`: object like :py:class:`.EngineBase`
          The engine to use for propagating a path.
        * `rgen`: object like :py:class:`.RandomGenerator`
          This is the random generator that will be used.
        * `interfaces`: list/tuple of floats
          These are the interface positions of the form
          ``[left, middle, right]``.

    tis_settings : dict
        This contains the settings for TIS. Here, we use the
        settings which dictates how we modify the velocities.
        * `aimless`: boolean, is the shooting aimless or not?

    Returns
    -------
    out[0] : object like :py:class:`.System`
        The shooting point with modified velocities.
    out[1] : integer
        The index of the shooting point in the original path.
    out[2] : float
        The change in kinetic energy when modifying the velocities.

    """
    shooting_point, idx = path.get_shooting_point(rgen)
    orderp = shooting_point.order
    shpt_copy = shooting_point.copy()
    logger.info("Shooting from order parameter/index: %f, %d", orderp[0], idx)
    # Copy the shooting point, so that we can modify velocities without
    # altering the original path:
    # Modify the velocities:
    tis_settings: dict[str, bool] = {}
    # TODO: REMOVE tis_settings?
    (
        dek,
        _,
    ) = engine.modify_velocities(
        shpt_copy,
        {
            "sigma_v": tis_settings.get("sigma_v", False),
            "aimless": tis_settings.get("aimless", True),
            "zero_momentum": tis_settings.get("zero_momentum", True),
            "rescale": tis_settings.get("rescale_energy", False),
        },
    )
    orderp = engine.calculate_order(shpt_copy)
    shpt_copy.order = orderp
    return shpt_copy, idx, dek


def check_kick(
    shooting_point: System,
    interfaces: list[float],
    trial_path: InfPath,
    rgen: Generator,
    dek: float,
) -> bool:
    """Check the modification of the shooting point.

    After generating velocities for a shooting point, we
    do some additional checking to see if the shooting point is
    acceptable.

    Parameters
    ----------
    shooting_point : object like :py:class:`.System`
        The shooting point with modified velocities.
    interfaces : list of floats
        The interfaces used for TIS, in the format
        ``[left, middle, right]``.
    trial_path : object like :py:class:`.PathBase`
        The path we are currently generating.
    rgen : object like :py:class:`.RandomGenerator`
        This is the random generator that will be used to check if
        we accept the shooting point based on the change in kinetic
        energy.
    dek : float
        The change in kinetic energy when modifying the velocities.
    tis_settings : dict
        This contains the settings for TIS.

    Returns
    -------
    out : boolean
        True if the kick was OK, False otherwise.

    """
    # 1) Check if the kick was too violent:
    left, _, right = interfaces
    tis_settings: dict[str, Any] = {}
    # TODO: REMOVE tis_settings above.
    if "exp" in tis_settings.get("shooting_move", {}):
        return True
    if not left <= shooting_point.order[0] < right:
        # Shooting point was velocity dependent and was kicked outside
        # print("wut", left, shooting_point.order[0], right)
        # exit('lel')
        # of boundaries when modifying velocities.
        trial_path.append(shooting_point)
        trial_path.status = "KOB"
        return False
    # 2) If the kick is not aimless, we check if we reject it or not:
    if not tis_settings.get("aimless", True):
        accept_kick = metropolis_accept_reject(rgen, shooting_point, dek)
        # If one wish to implement a bias call, this can be done here.
        if not accept_kick:
            trial_path.append(shooting_point)
            trial_path.status = "MCR"  # Momenta Change Rejection.
            return False
    return True


def retis_swap_zero(
    picked: dict[int, Any],
) -> tuple[bool, list[InfPath], str]:
    """Perform the RETIS swapping for ``[0^-] <-> [0^+]`` swaps.

    The RETIS swapping move for ensembles [0^-] and [0^+] requires some
    extra integration. Here we are generating new paths for [0^-] and
    [0^+] in the following way:

    1) For [0^-] we take the initial point in [0^+] and integrate
       backward in time. This is merged with the second point in [0^+]
       to give the final path. The initial point in [0^+] starts to the
       left of the interface and the second point is on the right
       side - i.e. the path will cross the interface at the end points.
       If we let the last point in [0^+] be called ``A_0`` and the
       second last point ``B``, and we let ``A_1, A_2, ...`` be the
       points on the backward trajectory generated from ``A_0`` then
       the final path will be made up of the points
       ``[..., A_2, A_1, A_0, B]``. Here, ``B`` will be on the right
       side of the interface and the first point of the path will also
       be on the right side.

    2) For [0^+] we take the last point of [0^-] and use that as an
       initial point to generate a new trajectory for [0^+] by
       integration forward in time. We also include the second last
       point of the [0^-] trajectory which is on the left side of the
       interface. We let the second last point be ``B`` (this is on the
       left side of the interface), the last point ``A_0`` and the
       points generated from ``A_0`` we denote by ``A_1, A_2, ...``.
       Then the resulting path will be ``[B, A_0, A_1, A_2, ...]``.
       Here, ``B`` will be on the left side of the interface and the
       last point of the path will also be on the left side of the
       interface.

    Parameters
    ----------
    ensembles : list of dictionaries of objects
        This is a list of the ensembles we are using in the RETIS method.
        It contains:

        * `path_ensemble`: object like :py:class:`.PathEnsemble`
          This is used for storing results for the simulation. It
          is also used for defining the interfaces for this simulation.
        * `system`: object like :py:class:`.System`
          System is used here since we need access to the temperature
          and to the particle list.
        * `order_function`: object like :py:class:`.OrderParameter`
          The class used for calculating the order parameter(s).
        * `engine`: object like :py:class:`.EngineBase`
          The engine to use for propagating a path.

    settings : dict
        This dict contains the settings for the RETIS method.
    cycle : integer
        The current cycle number.

    Returns
    -------
    out : string
        The result of the swapping move.

    """
    ens_set0 = picked[-1]["ens"]
    ens_set1 = picked[0]["ens"]
    engine0 = ENGINES[picked[-1]["eng_name"]]
    engine1 = ENGINES[picked[0]["eng_name"]]
    path_old0 = picked[-1]["traj"]
    path_old1 = picked[0]["traj"]
    maxlen0 = ens_set0.get("maxlength", DEFAULT_MAXLEN)
    maxlen1 = ens_set1.get("maxlength", DEFAULT_MAXLEN)

    ens_moves = [ens_set0["mc_move"], ens_set1["mc_move"]]
    intf_w = [list(ens_set0["interfaces"]), list(ens_set1["interfaces"])]

    # intf_w = [list(i) for i in (path_ensemble0.interfaces,
    #                             path_ensemble1.interfaces)]
    for i, mc_move in enumerate([ens_set0["tis_set"], ens_set1["tis_set"]]):
        intf_w[i][2] = mc_move.get("interface_cap", intf_w[i][2])

    # for i, j in enumerate([settings['ensemble'][k] for k in (0, 1)]):
    #     if ens_moves[i] == 'wf':
    #         intf_w[i][2] = j['tis'].get('interface_cap', intf_w[i][2])

    # 0. check if MD is allowed
    # allowed = (path_ensemble0.last_path.get_end_point(
    #             path_ensemble0.interfaces[0],
    #             path_ensemble0.interfaces[-1]) == 'R')
    allowed = (
        path_old0.get_end_point(
            ens_set0["interfaces"][0], ens_set0["interfaces"][-1]
        )
        == "R"
    )
    # if allowed:
    #     swap_ensemble_attributes(ensemble0, ensemble1, settings)

    # 1. Generate path for [0^-] from [0^+]:
    # We generate from the first point of the path in [0^+]:
    logger.debug("Swapping [0^-] <-> [0^+]")
    logger.debug("Creating path for [0^-]")
    # system = path_ensemble1.last_path.phasepoints[0].copy()
    shpt_copy = path_old1.phasepoints[0].copy()
    # shpt_copy2 = path_old1.phasepoints[0].copy()
    logger.debug("Initial point is: %s", shpt_copy)
    # Propagate it backward in time:
    path_tmp = path_old1.empty_path(maxlen=maxlen1 - 1)
    if allowed:
        logger.debug("Propagating for [0^-]")
        engine0.propagate(path_tmp, ens_set0, shpt_copy, reverse=True)
    else:
        logger.debug("Not propagating for [0^-]")
        path_tmp.append(shpt_copy)
    path0 = path_tmp.empty_path(maxlen=maxlen0)
    for phasepoint in reversed(path_tmp.phasepoints):
        path0.append(phasepoint)
    # print('lobster a', path_tmp.length, path0.length, allowed)
    # Add second point from [0^+] at the end:
    logger.debug("Adding second point from [0^+]:")
    # Here we make a copy of the phase point, as we will update
    # the configuration and append it to the new path:
    # phase_point = path_ensemble1.last_path.phasepoints[1].copy()
    phase_point = path_old1.phasepoints[1].copy()
    logger.debug("Point is %s", phase_point)
    engine1.dump_phasepoint(phase_point, "second")
    path0.append(phase_point)
    if path0.length == maxlen0:
        path0.status = "BTX"
    elif path0.length < 3:
        path0.status = "BTS"
    elif (
        "L" not in set(ens_set0["start_cond"])
        and "L" in path0.check_interfaces(ens_set0["interfaces"])[:2]
    ):
        path0.status = "0-L"
    else:
        path0.status = "ACC"
    # print(path0.status)

    # 2. Generate path for [0^+] from [0^-]:
    logger.debug("Creating path for [0^+] from [0^-]")
    # This path will be generated starting from the LAST point of [0^-] which
    # should be on the right side of the interface. We will also add the
    # SECOND LAST point from [0^-] which should be on the left side of the
    # interface, this is added after we have generated the path and we
    # save space for this point by letting maxlen = maxlen1-1 here:
    path_tmp = path0.empty_path(maxlen=maxlen1 - 1)
    # We start the generation from the LAST point:
    # Again, the copy below is not needed as the propagate
    # method will not alter the initial state.
    # system = path_ensemble0.last_path.phasepoints[-1].copy()
    system = path_old0.phasepoints[-1].copy()
    if allowed:
        logger.debug("Initial point is %s", system)
        # nsembles[1]['system'] = system
        logger.debug("Propagating for [0^+]")
        engine1.propagate(path_tmp, ens_set1, system, reverse=False)
        # Ok, now we need to just add the SECOND LAST point from [0^-] as
        # the first point for the path:
        path1 = path_tmp.empty_path(maxlen=maxlen1)
        # phase_point = path_ensemble0.last_path.phasepoints[-2].copy()
        phase_point = path_old0.phasepoints[-2].copy()
        logger.debug("Add second last point: %s", phase_point)
        engine0.dump_phasepoint(phase_point, "second_last")
        path1.append(phase_point)
        path1 += path_tmp  # Add rest of the path.
    else:
        path1 = path_tmp
        path1.append(system)
        logger.debug("Skipping propagating for [0^+] from L")

    ##### NB if path_ensemble1.last_path.get_move() != 'ld':
    ##### NB     path0.set_move('s+')
    ##### NB else:
    ##### NB     path0.set_move('ld')

    ##### NB if path_ensemble0.last_path.get_move() != 'ld':
    ##### NB     path1.set_move('s-')
    ##### NB else:
    ##### NB     path1.set_move('ld')
    if path1.length >= maxlen1:
        path1.status = "FTX"
    elif path1.length < 3:
        path1.status = "FTS"
    else:
        path1.status = "ACC"
    logger.debug("Done with swap zero!")

    # Final checks:
    accept = path0.status == "ACC" and path1.status == "ACC"
    status = (
        "ACC"
        if accept
        else (path0.status if path0.status != "ACC" else path1.status)
    )
    # High Acceptance swap is required when Wire Fencing are used
    if accept:
        if "wf" in ens_moves:
            accept, status = high_acc_swap(
                [path1, path_old1],
                ens_set0["rgen"],
                intf_w[0],
                intf_w[1],
                ens_moves,
            )

    for i, path, tis_set, flag in (
        (0, path0, ens_set0["tis_set"], "s+"),
        (1, path1, ens_set1["tis_set"], "s-"),
    ):
        if not accept and path.status == "ACC":
            path.status = status

        # These should be 1 unless length of paths equals 3.
        # This technicality is not yet fixed. (An issue is open as a reminder)

        # ens_set = settings['ensemble'][i]
        move = ens_moves[i]
        path.weight = (
            compute_weight(path, intf_w[i], move) if move in ("wf") else 1
        )

    return accept, [path0, path1], status


def metropolis_accept_reject(
    rgen: Generator, system: System, deltae: float
) -> bool:
    """accept/reject a energy change according to the metropolis rule.

    fixme: check if metropolis really is a good name here.

    parameters
    ----------
    rgen : object like :py:class:`.randomgenerator`
        the random number generator.
    system : object like :py:class:`.system`
        the system object we are investigating. this is used
        to access the beta factor.
    deltae : float
        The change in energy.

    Returns
    -------
    out : boolean
        True if the move is accepted, False otherwise.

    Notes
    -----
    An overflow is possible when using `numpy.exp()` here.
    This can, for instance, happen in an umbrella simulation
    where the bias potential is infinite or very large.
    Right now, this is just ignored.

    """
    if deltae < 0.0:  # short-cut to avoid calculating np.exp()
        return True
    pacc = np.exp(-system.temperature["beta"] * deltae)
    return rgen.random() < pacc


def high_acc_swap(
    paths: list[InfPath],
    rgen: Generator,
    intf0: list[float],
    intf1: list[float],
    ens_moves: list[str],
) -> tuple[bool, str]:
    """Accept or Reject a swap move using the High Acceptance weights.

    Parameters
    ----------
    paths: list of object like :py:class:`.PathBase`
        The path in the LOWER and UPPER ensemble to exchange.
    rgen : object like :py:class:`.RandomGenerator`
        This is a random generator.
    intf0: list of float
        The interfaces of the LOWER ensemble.
    intf1: list of float
        The interfaces of the HIGHER ensemble.
    ens_moves: list of string
        The moves used in the two ensembles.

    Returns
    -------
    out[0] : boolean
        True if the move should be accepted.

    Notes
    -----
     -  This function is needed only when paths generated via Wire Fencing or
        Stone Skipping are involved.
      - In the case that a path bears a flag 'ld', the swap is accepted,
            but the flag will be unchanged.

    """
    # Crossing before the move
    c1_old = compute_weight(paths[0], intf0, ens_moves[0])
    c2_old = compute_weight(paths[1], intf1, ens_moves[1])
    # Crossing if the move would be accepted
    c1_new = compute_weight(paths[1], intf0, ens_moves[0])
    c2_new = compute_weight(paths[0], intf1, ens_moves[1])
    if c1_old == 0 or c2_old == 0:
        logger.warning(
            "div_by_zero. c1_old, c2_old, ens_moves: [%i,%i], %s",
            c1_old,
            c2_old,
            str(ens_moves),
        )
        p_swap_acc = 1.0
    else:
        p_swap_acc = c1_new * c2_new / (c1_old * c2_old)

    # Finally, randomly decide to accept or not:
    if rgen.random() < p_swap_acc:
        return True, "ACC"  # Accepted

    return False, "HAS"  # Rejected
